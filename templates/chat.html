<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Cold War Game Master</title>
  <style>
    #chat-box {
    font-family: Georgia, serif;
    white-space: pre-wrap; /* This preserves line breaks and spacing */
    line-height: 1.6;
    padding: 1em;
    max-height: 80vh;
    overflow-y: auto;
    background: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 8px;
  }

  .message {
    margin-bottom: 1.5em;
  }

  .user {
    color: #003366;
    font-weight: bold;
  }

  .gm {
    color: #222;
    background-color: #fffbea;
    padding: 0.5em;
    border-left: 4px solid #999900;
    border-radius: 4px;
  }

  .gm strong {
    color: #663300;
  }

  .gm-options {
    margin-top: 0.5em;
    font-weight: bold;
  }
  #agency-overlay button {
  margin: 0.5em;
  padding: 0.75em 1.5em;
  font-size: 1em;
  cursor: pointer;
}
</style>
</head>

<body>
  <h2>Cold War Game Master</h2>
    <div id="agency-overlay" style="position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.8); z-index:9999; display: flex; justify-content: center; align-items: center;">
      <div style="background:white; padding: 2em; border-radius:10px; text-align:center; max-width: 400px;">
        <h3>Select Your Intelligence Agency</h3>
        <button onclick="selectAgency('CIA')">CIA</button>
        <button onclick="selectAgency('KGB')">KGB</button>
        <button onclick="selectAgency('SIS')">SIS</button>
      </div>
    </div>
  <div id="chat-box"></div>
  <input type="text" id="user-input" placeholder="Type your message..." style="width:80%;" autofocus>
  <button id="send-button">Send</button>
  <button id="send-end-button">Send & End Turn</button>
  <small>(Ctrl+Enter to send & end turn)</small>
  <script>
function getSessionId() {
  const match = document.cookie.match(/(^| )session_id=([^;]+)/);
  return match ? match[2] : null;
}

function setSessionId(id) {
  document.cookie = `session_id=${id}; path=/; max-age=31536000`; // 1 year
}

let sessionId = getSessionId();
if (!sessionId) {
  sessionId = crypto.randomUUID();  // modern browsers only
  setSessionId(sessionId);
}

let ws = null;
let wsConnected = false;
let wsMessageQueue = [];  // queue messages sent before WS ready
async function selectAgency(agency) {
  const sessionId = getSessionId(); // Make sure this exists and returns a valid session ID

  if (!sessionId || !agency) {
    console.error("Missing session ID or agency");
    return;
  }

  try {
    const response = await fetch("/session/set-newgame", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        session_id: sessionId,
        agency: agency,
      }),
    });

    const data = await response.json();

    if (response.ok && data.success) {
      // Hide overlay only if agency was set successfully
      const overlay = document.getElementById("agency-overlay");
      if (overlay) {
        overlay.style.display = "none";
      }
      console.log("Agency set to", agency);
    } else {
      console.error("Failed to set agency:", data.error || "Unknown error");
      alert("Failed to set agency.");
    }
  } catch (err) {
    console.error("Error communicating with server:", err);
    alert("Failed to contact server.");
  }
}
function connectWebSocket() {
  ws = new WebSocket(`${location.protocol === "https:" ? "wss" : "ws"}://${window.location.host}/ws/talk/gamemaster`);
  ws.onopen = () => {
    wsConnected = true;
    console.log("WebSocket connected");
    // Send any queued messages that were triggered before connection
    while (wsMessageQueue.length) {
      const msg = wsMessageQueue.shift();
      ws.send(JSON.stringify(msg));
    }
  };
  ws.onmessage = (event) => {
    console.log("WS message received:", event.data);
    appendToLatestGMMessage(event.data);
    
  };
  ws.onclose = () => {
    wsConnected = false;
    console.log("WebSocket disconnected, fallback to HTTP");
  };
  ws.onerror = (err) => {
    wsConnected = false;
    console.log("WebSocket error, fallback to HTTP", err);
  };
}

// Append chunks to the last GM message streaming span
function appendToLatestGMMessage(chunk) {
  const chatBox = document.getElementById("chat-box");
  const gmMessages = chatBox.getElementsByClassName("message gm");
  if (gmMessages.length === 0) return;  // no GM messages yet
  const lastGMMessage = gmMessages[gmMessages.length - 1];
  const streamingSpan = lastGMMessage.querySelector(".streaming-response");
  if (!streamingSpan) return;
  streamingSpan.textContent += chunk;
  chatBox.scrollTop = chatBox.scrollHeight;
}

async function sendMessage(endTurn = false) {
  const input = document.getElementById("user-input");
  const message = input.value.trim();
  if (!message) return;

  const chatBox = document.getElementById("chat-box");
  chatBox.innerHTML += `<div class="message user"><strong>You:</strong> ${message}</div>`;
  input.value = "";

  // Disable inputs while streaming
  input.disabled = true;
  document.getElementById("send-button").disabled = true;
  document.getElementById("send-end-button").disabled = true;

  // Add a new GM message container with empty streaming span
  const gmMessageDiv = document.createElement("div");
  gmMessageDiv.className = "message gm";
  gmMessageDiv.innerHTML = `<strong>GM:</strong> <span class="streaming-response"></span>`;
  chatBox.appendChild(gmMessageDiv);

  if (wsConnected) {
    // Use WebSocket streaming
    try {
      // Send message over WS
      const msgObj = {
        message: message,
        session_id: sessionId,
        force_end_turn: endTurn,
      };

      // If WS ready, send directly, else queue
      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify(msgObj));
      } else {
        wsMessageQueue.push(msgObj);
      }
    } catch (err) {
      console.error("WebSocket send error, fallback to HTTP:", err);
      await fallbackHttpStreaming(message, endTurn, gmMessageDiv);
    } finally {
      input.disabled = false;
      document.getElementById("send-button").disabled = false;
      document.getElementById("send-end-button").disabled = false;
      input.focus();
    }
  } else {
    // WebSocket not connected or failed, fallback to HTTP POST streaming
    await fallbackHttpStreaming(message, endTurn, gmMessageDiv);
  }
  chatBox.scrollTop = chatBox.scrollHeight;
}

// Fallback streaming with HTTP POST endpoint
async function fallbackHttpStreaming(message, endTurn, gmMessageDiv) {
  const input = document.getElementById("user-input");
  const chatBox = document.getElementById("chat-box");
  const responseSpan = gmMessageDiv.querySelector(".streaming-response");

  try {
    const response = await fetch("/talk/gamemaster", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        message: message,
        session_id: sessionId,
        force_end_turn: endTurn,
      }),
    });

    if (!response.ok || !response.body) {
      throw new Error("Network response was not ok or readable stream missing");
    }

    const reader = response.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let done = false;

    while (!done) {
      const { value, done: doneReading } = await reader.read();
      done = doneReading;
      if (value) {
        const chunk = decoder.decode(value, { stream: true });
        responseSpan.textContent += chunk;
        chatBox.scrollTop = chatBox.scrollHeight;
      }
    }
  } catch (error) {
    responseSpan.innerHTML += `<br><span style="color:red;">[Error receiving response]</span>`;
    console.error("Fallback HTTP streaming error:", error);
  } finally {
    input.disabled = false;
    document.getElementById("send-button").disabled = false;
    document.getElementById("send-end-button").disabled = false;
    input.focus();
  }
}

// Try connecting WebSocket on page load
window.addEventListener("DOMContentLoaded", async () => {
  if (!sessionId) return;

  try {
    const response = await fetch(`/session/${sessionId}`);
    const data = await response.json();

    const chatbox = document.getElementById("chat-box");
    data.messages.forEach(msg => {
      const roleClass = msg.sender === "user" ? "user" : "gm";
      const label = msg.sender === "user" ? "You" : "GM";
      chatbox.innerHTML += `<div class="message ${roleClass}"><strong>${label}:</strong> ${msg.content}</div>`;
    });

    if (data.session_metadata && !data.session_metadata.agency) {
      document.getElementById("agency-overlay").style.display = "flex";
    } else {
      document.getElementById("agency-overlay").style.display = "none";
    }
    if (data.session_metadata) {
      console.log("Session restored:", data.session_metadata);
    }
    chatbox.scrollTop = chatbox.scrollHeight;

    // Now open WebSocket connection (try primary)
    connectWebSocket();
  } catch (err) {
    console.error("Failed to load previous session:", err);
  }
});

// Listen for key presses: Enter sends, Ctrl+Enter sends & ends turn
document.getElementById("user-input").addEventListener("keydown", function (e) {
  if (e.ctrlKey && e.key === "Enter") {
    e.preventDefault();
    sendMessage(true);  // Send and end turn
  } else if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    sendMessage(false);  // Just send
  }
});

// Send buttons
document.getElementById("send-button").addEventListener("click", function () {
  sendMessage(false);
});
document.getElementById("send-end-button").addEventListener("click", function () {
  sendMessage(true);
});
</script>

</body>
</html>